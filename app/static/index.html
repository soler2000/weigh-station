<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Weigh Station – Home</title>
  <!-- use the shared theme exactly like other pages -->
  <link rel="stylesheet" href="/static/styles.css?v=app-theme-1">
  <style>
    /* Only minimal, page-local helpers (theme stays in styles.css) */
    :root { --gap: 16px; }
    .page { max-width: 1200px; margin: 0 auto; padding: var(--gap); }
    .layout { display:grid; grid-template-columns: 2fr 1fr; gap: var(--gap); }
    @media (max-width: 980px) { .layout { grid-template-columns: 1fr; } }

    .reading-card{display:flex;flex-direction:column;align-items:center;justify-content:center;min-height:40vh}
    .reading{font-weight:800;font-size:clamp(56px,12vw,144px);line-height:1;letter-spacing:-.02em}
    .reading-sub{opacity:.85;margin-top:6px;color:#cbd5f5}
    .status--pass{ background: rgba(35,173,78,.08) }  /* soft green tint */
    .status--fail{ background: rgba(214,57,57,.08) } /* soft red tint  */

    .weight-bounds{margin-top:22px;display:grid;grid-template-columns:repeat(auto-fit,minmax(140px,1fr));gap:14px;width:100%;max-width:420px}
    .weight-bound{background:rgba(255,255,255,.04);border-radius:14px;padding:12px 16px;text-align:center}
    .weight-bound .label{display:block;opacity:.7;font-size:0.9rem;margin-bottom:6px}
    .weight-bound .value{font-weight:600;font-size:1.35rem;letter-spacing:.01em}

    .formgrid{display:grid;grid-template-columns:150px 1fr;gap:10px 14px;align-items:center}
    .formgrid textarea{min-height:110px;resize:vertical}
    .actions{display:flex;gap:10px;flex-wrap:wrap;margin-top:12px}
    .kpis{display:grid;grid-template-columns:repeat(3,minmax(120px,1fr));gap:12px;margin-top:12px}
    .kpis .num{font-weight:700;font-size:clamp(20px,3.5vw,32px);text-align:center}
    .status-msg{min-height:2.4em;margin-bottom:18px;font-size:2rem;line-height:1.2;font-weight:600;text-align:center;color:#e2e8f0}
  </style>
</head>
<body class="app dark">
  <!-- same “chrome” as the other pages -->
  <header class="card topbar">
    <div class="brand">
      <img src="/static/gentex-logo.svg" alt="Gentex Corporation" class="brand-logo">
      <span class="brand-title">Weigh Station</span>
    </div>
    <nav class="nav">
      <a href="/" class="active">Home</a>
      <a href="/settings">Settings</a>
      <a href="/production">Production</a>
      <a href="/stats">Stats</a>
      <a href="/export">Export</a>
      <a href="/serial-log">Serial Log</a>
    </nav>
  </header>

  <main class="page">
    <div class="layout">
      <!-- Left: live reading -->
      <section class="card reading-card" id="readingCard">
        <div id="msg" class="status-msg"></div>
        <div id="reading" class="reading">0.0 g</div>
        <div id="readingSub" class="reading-sub">Waiting for scale…</div>
        <div class="weight-bounds" aria-live="polite">
          <div class="weight-bound">
            <span class="label">Minimum Weight</span>
            <span id="minWeight" class="value">–</span>
          </div>
          <div class="weight-bound">
            <span class="label">Maximum Weight</span>
            <span id="maxWeight" class="value">–</span>
          </div>
        </div>
      </section>

      <!-- Right: controls -->
      <section class="card" style="padding:14px">
        <div class="formgrid">
          <label for="mouldingSerial">Moulding Serial</label>
          <input id="mouldingSerial" type="text" placeholder="Enter moulding serial">

          <label for="variant">Variant</label>
          <select id="variant"></select>

          <label for="contract">Contract</label>
          <input id="contract" type="text" placeholder="Contract number">

          <label for="orderNumber">Order Number</label>
          <input id="orderNumber" type="text" placeholder="Order number">

          <label for="operator">Operator</label>
          <input id="operator" type="text" placeholder="Operator name">

          <label for="colour">Colour</label>
          <select id="colour">
            <option value="">Select colour</option>
          </select>

          <label for="finalSerial">Final Serial</label>
          <input id="finalSerial" type="text" placeholder="Scan or enter final serial" autocomplete="off">

          <label for="notes">Notes</label>
          <textarea id="notes" placeholder="Notes for this weigh"></textarea>
        </div>

        <div class="actions">
          <button id="saveBtn">Save</button>
        </div>

        <div class="muted" style="margin-top:16px;margin-bottom:4px;font-size:0.95rem">Totals for today</div>
        <div class="kpis">
          <div class="card" style="padding:10px"><div style="opacity:.7">Pass</div><div id="passCount" class="num">0</div></div>
          <div class="card" style="padding:10px"><div style="opacity:.7">Fail</div><div id="failCount" class="num">0</div></div>
          <div class="card" style="padding:10px"><div style="opacity:.7">Total</div><div id="totalCount" class="num">0</div></div>
        </div>
      </section>
    </div>
  </main>

<script>
const $ = (id)=>document.getElementById(id);
const TZ_OFFSET_MINUTES = new Date().getTimezoneOffset();
let currentVariant = null;
let latestReading = {g: 0};
let requireZeroReset = false;
let zeroPromptActive = false;

const ZERO_TOLERANCE_G = 0.5;
const STICKY_FIELDS = ['mouldingSerial','contract','orderNumber','operator','colour'];
const STICKY_STORAGE_KEY = 'weighStationStickyFields';
const STICKY_TTL_MS = 30 * 60 * 1000;

function boundLabel(value){
  if(value === null || value === undefined) return '–';
  const num = Number(value);
  if(Number.isFinite(num)) return `${num} g`;
  const text = String(value ?? '').trim();
  return text || '–';
}

function updateWeightBounds(variant){
  const minEl = $('minWeight');
  const maxEl = $('maxWeight');
  if(minEl) minEl.textContent = variant ? boundLabel(variant.min_g) : '–';
  if(maxEl) maxEl.textContent = variant ? boundLabel(variant.max_g) : '–';
}

function fmtG(x){ return (Math.round(x*10)/10).toFixed(1)+' g'; }
function setMsg(t, ok=true){ const m=$('msg'); if(!m) return; m.textContent=t||''; m.style.color = ok ? '' : '#b00'; }
function tint(weight, variant){
  const card = $('readingCard');
  if(!card) return;
  card.classList.remove('status--pass','status--fail');
  const g = Number(weight ?? 0);
  if(Math.abs(g) < 5) return;
  if(!variant) return;
  if(g >= variant.min_g && g <= variant.max_g){
    card.classList.add('status--pass');
  } else {
    card.classList.add('status--fail');
  }
}

async function loadVariants(){
  try{
    const v = await fetch('/api/variants',{cache:'no-store'}).then(r=>r.json());
    const sel = $('variant'); if(!sel) return;
    sel.innerHTML='';
    for(const it of v){
      const o=document.createElement('option');
      o.value=it.id; o.textContent=it.name || (`Variant ${it.id}`);
      sel.appendChild(o);
    }
    if(v.length){
      sel.value=v[0].id;
      currentVariant=v[0];
      updateWeightBounds(currentVariant);
      tint(latestReading?.g ?? 0, currentVariant);
      refreshStats();
    } else {
      currentVariant=null;
      updateWeightBounds(null);
    }
    sel.addEventListener('change', ()=>{
      const id=parseInt(sel.value,10);
      currentVariant = v.find(x=>x.id===id) || null;
      updateWeightBounds(currentVariant);
      tint(latestReading?.g ?? 0, currentVariant);
      refreshStats();
    });
  }catch{
    setMsg('Failed to load variants', false);
    updateWeightBounds(null);
  }
}

function updateScreen(d){
  if(!d || typeof d.g !== 'number') return;
  latestReading = d;
  $('reading').textContent = fmtG(d.g);
  const sub = $('readingSub');
  if(sub){
    sub.textContent = `Last update • ${new Date().toLocaleTimeString()}`;
  }
  if(requireZeroReset && Math.abs(d.g) <= ZERO_TOLERANCE_G){
    requireZeroReset = false;
    if(zeroPromptActive){
      setMsg('Scale back to zero – ready for next part.');
      zeroPromptActive = false;
    }
  }
  tint(d.g, currentVariant);
}

// WebSocket + polling fallback
(function connectWS(){
  const proto = (location.protocol === 'https:') ? 'wss' : 'ws';
  const ws = new WebSocket(`${proto}://${location.host}/ws/weight`);
  ws.onmessage = ev => { try { updateScreen(JSON.parse(ev.data)); } catch{} };
  ws.onclose   = () => setTimeout(connectWS, 1200);
})();
setInterval(async ()=>{
  try{
    const d = await fetch('/api/debug/latest',{cache:'no-store'}).then(r=>r.json());
    if(d && typeof d.g==='number') updateScreen(d);
  }catch{}
}, 1500);

async function refreshStats(){
  try{
    const params = new URLSearchParams();
    if(currentVariant) params.set('variant_id', currentVariant.id);
    params.set('tz_offset', String(TZ_OFFSET_MINUTES));
    const s = await fetch('/api/stats'+(params.toString()?`?${params}`:''),{cache:'no-store'}).then(r=>r.json());
    $('passCount').textContent  = s.pass ?? 0;
    $('failCount').textContent  = s.fail ?? 0;
    $('totalCount').textContent = s.total ?? 0;
  }catch{}
}

function readSticky(){
  try{
    const raw = localStorage.getItem(STICKY_STORAGE_KEY);
    return raw ? JSON.parse(raw) : null;
  }catch{
    localStorage.removeItem(STICKY_STORAGE_KEY);
    return null;
  }
}

async function loadColours(){
  try{
    const url = `/api/colours?ts=${Date.now()}`;
    const res = await fetch(url,{cache:'no-store'});
    if(!res.ok) throw new Error('Colour request failed');
    let items = await res.json();
    if(items && Array.isArray(items.items)) items = items.items;
    const sel = $('colour'); if(!sel) return;
    const previous = sel.value;
    const sticky = readSticky();
    const stickyColour = sticky?.values?.colour ?? '';
    sel.innerHTML = '<option value="">Select colour</option>';
    const seen = new Set();
    if(Array.isArray(items)){
      for(const row of items){
        const name = typeof row === 'string' ? row : (row?.name ?? '');
        const clean = String(name).trim();
        if(!clean || seen.has(clean)) continue;
        const opt = document.createElement('option');
        opt.value = clean;
        opt.textContent = clean;
        sel.appendChild(opt);
        seen.add(clean);
      }
    }
    const desired = stickyColour || previous;
    if(desired && Array.from(sel.options).some(opt => opt.value === desired)){
      sel.value = desired;
    }
  }catch(err){
    const sel = $('colour');
    if(sel){
      const current = sel.value;
      sel.innerHTML = '<option value="">Select colour</option>';
      if(current && Array.from(sel.options).some(opt => opt.value === current)){
        sel.value = current;
      }
    }
  }
}

function clearStickyFields(clearInputs=true){
  localStorage.removeItem(STICKY_STORAGE_KEY);
  if(clearInputs){
    for(const id of STICKY_FIELDS){
      const el = $(id);
      if(el) el.value='';
    }
  }
}

function applyStickyFields(){
  const data = readSticky();
  if(!data) return;
  const ts = Number(data.ts);
  if(!ts || (Date.now()-ts) > STICKY_TTL_MS){
    clearStickyFields();
    return;
  }
  const values = data.values || {};
  for(const id of STICKY_FIELDS){
    if(Object.prototype.hasOwnProperty.call(values, id)){
      const el = $(id);
      if(!el) continue;
      const value = values[id] ?? '';
      if(el.tagName === 'SELECT'){
        const match = Array.from(el.options || []).some(opt => opt.value === value);
        el.value = match ? value : '';
      } else {
        el.value = value;
      }
    }
  }
}

function persistStickyFields(){
  const values = {};
  for(const id of STICKY_FIELDS){
    const el = $(id);
    values[id] = el ? el.value ?? '' : '';
  }
  try{
    localStorage.setItem(STICKY_STORAGE_KEY, JSON.stringify({ts: Date.now(), values}));
  }catch{}
}

function bindStickyHandlers(){
  for(const id of STICKY_FIELDS){
    const el = $(id);
    if(!el) continue;
    el.addEventListener('input', persistStickyFields);
    el.addEventListener('change', persistStickyFields);
  }
}

function checkStickyExpiry(){
  const data = readSticky();
  if(!data) return;
  const ts = Number(data.ts);
  if(!ts || (Date.now()-ts) > STICKY_TTL_MS){
    clearStickyFields();
  }
}

async function doSave(){
  try{
    if(!currentVariant){ setMsg('Choose variant first', false); return; }
    const finalSerialEl = $('finalSerial');
    const serial = (finalSerialEl?.value || '').trim();
    if(!serial){ setMsg('Final serial cannot be blank', false); finalSerialEl?.focus(); return; }

    if(requireZeroReset && Math.abs(latestReading?.g ?? 0) > ZERO_TOLERANCE_G){
      zeroPromptActive = true;
      setMsg('Remove product and allow the scale to return to zero before saving.', false);
      return;
    }

    const params = new URLSearchParams();
    params.set('variant_id', String(currentVariant.id));
    params.set('serial', serial);
    params.set('moulding_serial', ($('mouldingSerial')?.value || '').trim());
    params.set('contract', ($('contract')?.value || '').trim());
    params.set('order_number', ($('orderNumber')?.value || '').trim());
    params.set('operator', ($('operator')?.value || '').trim());
    params.set('colour', ($('colour')?.value || '').trim());
    params.set('notes', ($('notes')?.value || '').trim());

    const submit = (searchParams) => fetch(`/api/weigh/commit?${searchParams}`, {method:'POST'});
    const onSuccess = () => {
      setMsg('Saved – remove product and return the scale to zero.');
      zeroPromptActive = true;
      requireZeroReset = true;
      if(finalSerialEl) finalSerialEl.value='';
      const notesEl = $('notes');
      if(notesEl) notesEl.value='';
      persistStickyFields();
      refreshStats();
      finalSerialEl?.focus();
    };

    const initialRes = await submit(params.toString());
    if(initialRes.status === 409){
      let detail = null;
      try{ detail = await initialRes.json(); }catch{}
      const message = (detail && typeof detail === 'object')
        ? (detail.detail?.message || detail.message || detail.detail)
        : null;
      const promptMsg = message
        ? `${message} Update the existing record with the new values?`
        : 'Duplicate serial detected. Update the existing record with the new values?';
      if(confirm(promptMsg)){
        params.set('overwrite','true');
        const overwriteRes = await submit(params.toString());
        if(!overwriteRes.ok){ setMsg('Save failed', false); return; }
        onSuccess();
      } else {
        setMsg('Save cancelled – existing record not updated.', false);
        finalSerialEl?.focus();
      }
      return;
    }
    if(!initialRes.ok){ setMsg('Save failed', false); return; }
    onSuccess();
  }catch{ setMsg('Save error', false); }
}

window.addEventListener('load', async ()=>{
  checkStickyExpiry();
  await loadColours();
  applyStickyFields();
  bindStickyHandlers();
  setInterval(checkStickyExpiry, 60000);
  loadVariants();
  setInterval(refreshStats, 3000);
  $('saveBtn')?.addEventListener('click', doSave);
  $('finalSerial')?.addEventListener('keydown', ev=>{ if(ev.key==='Enter'){ ev.preventDefault(); }});
  $('finalSerial')?.focus();
});
</script>
</body>
</html>